/*
 Navicat Premium Data Transfer

 Source Server         : root
 Source Server Type    : MySQL
 Source Server Version : 80021
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80021
 File Encoding         : 65001

 Date: 15/06/2022 15:55:04
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(15) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `first_picture` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `flag` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `views` int NULL DEFAULT NULL,
  `appreciation` int NULL DEFAULT NULL,
  `share_statement` int NULL DEFAULT NULL,
  `comment_able` int NULL DEFAULT NULL,
  `published` int NULL DEFAULT NULL,
  `recommend` int NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `description` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `type_id` int NULL DEFAULT NULL,
  `user_id` int NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (1, '深入理解JVM', '# JVM\r\n\r\n\r\n\r\n## 1. 运行时数据区域\r\n\r\n![image-20210910190733906.png](https://i.loli.net/2021/09/22/vL5soN2Vkydf4Ql.png)\r\n\r\n\r\n### 1.1 程序计数器\r\n\r\n​        由于Java虚拟机的多线程是通过线程轮流切换、 分配处理器执行时间的方式来实现的， 在任何一个确定的时刻， 一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。 因此， 为了线程切换后能恢复到正确的执行位置， 每条线程都需要有一个独立的程序计数器， 各条线程之间计数器互不影响， 独立存储， 我们称这类内存区域为“线程私有”的内存。  \r\n\r\n\r\n\r\n### 1.2 虚拟机栈\r\n\r\n​        虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型： 每个方法被执行的时候， Java虚拟机都会同步创建一个栈帧（Stack Frame） 用于存储局部变量表、 操作数栈、 动态连接、 方法出口等信息。 每一个方法被调用直至执行完毕的过程， 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\r\n\r\n​        局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、 byte、 char、 short、 int、float、 long、 double） 、 对象引用（reference类型， 它并不等同于对象本身， 可能是一个指向对象起始地址的引用指针， 也可能是指向一个代表对象的句柄或者其他与此对象相关的位置） 和returnAddress类型（指向了一条字节码指令的地址）。\r\n\r\n\r\n\r\n### 1.3 本地方法栈\r\n\r\n​        本地方法栈与虚拟机栈的作用是非常相似的，区别是本地方法栈是为虚拟机使用到的本地方法服务。\r\n\r\n\r\n\r\n### 1.4 Java堆\r\n\r\n​        Java堆是一块被所有线程所共享的内存区域，在虚拟机启动时创建。\r\n\r\n​        Java8以后，字符串常量池，静态变量都是在堆中。\r\n\r\n​        Java中所有的对象实例都在这里进行分配内存。\r\n\r\n\r\n\r\n### 1.5 方法区\r\n\r\n​        各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、字段、方法、 接口等，同时运行时常量池也是在方法区中的\r\n\r\n\r\n\r\n### 1.6 运行时常量池\r\n\r\n​        运行时常量池是方法区的一部分\r\n\r\n\r\n\r\n## 2.  HotSpot虚拟机对象\r\n\r\n\r\n\r\n### 2.1 对象的创建\r\n\r\n​        当Java虚拟机遇到一条字节码new指令时， 首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用， 并且检查这个符号引用代表的类是否已被加载、 解析和初始化过。 如果没有， 那必须先执行相应的类加载过程。\r\n\r\n​        在类加载检查通过后，接下来虚拟机为新生对象在堆中分配内存。\r\n\r\n​        假设Java堆内存是绝对规整的，所有被使用的内存都放在一边，另一边都是空间的内存，中间有一个作为分界点的指针，分配内存就是把这个分界点指针向右移动与对象大小相等的距离，这种分配方式叫做**“指针碰撞”**。\r\n\r\n​        但假设Java堆内存是不规整的，已被使用的内存和空间的内存是交错在一起，此时虚拟机就会维护一个列表，记录哪些内存已被使用，哪些是空闲的，分配内存的时候在列表中找到一块够用的空间给对象分配内存，并且在列表上更新，这种分配方式叫做**“空闲列表”**。\r\n\r\n​        选择哪种分配方式，由Java堆是否规整决定，Java堆是否规整由垃圾收集器是否采用带有压缩整理的能力决定。\r\n\r\n​        还需另外考虑一个问题：目前大多数应用是多线程的，所以内存分配是多线程的，都从主内存中分配，使用CAS 更新重试过于频繁导致效率低下。一般每个线程分配内存的特性是比较稳定的。这里的比较稳定指的是，每次分配对象的大小，每轮 GC 分配区间内的分配对象的个数以及总大小。所以，我们可以考虑每个线程分配内存后，就将这块内存保留起来，用于下次分配，这样就不用每次从主内存中分配了。如果能估算每轮 GC 内每个线程使用的内存大小，则可以提前分配好内存给线程，这样就更能提高分配效率。这种内存分配的实现方式，在 JVM 中就是 **TLAB （Thread Local Allocate Buffer）**。\r\n\r\n\r\n\r\n### 2.2 对象的内存布局\r\n\r\n​        对象在堆内存中的存储布局可以划分为三个部分：**对象头、实例数据和对齐填充**。\r\n\r\n​        **对象头**可以包括两类信息。第一类是用于存储对象自身的运行时数据， 如哈希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等，叫做**“Mark Word”**。  \r\n\r\n​        另一部分是类型指针（Klass Pointer），Java虚拟机通过这个指针来确定该对象是哪个类的实例。\r\n\r\n​        **实例数据**是对象真正存储的有效信息。\r\n\r\n​        对齐填充是因为HotSpot虚拟机要求对象大小都必须是8字节的整数倍。\r\n\r\n\r\n\r\n### 2.3 对象的访问\r\n\r\n​        创建对象之后，Java虚拟机会通过栈上的reference引用来操作堆上的具体对象。从栈上的引用访问堆上的实例主要由两种方式：\r\n\r\n​        \r\n\r\n1. 通过句柄\r\n\r\n![image-20210910195745111.png](https://i.loli.net/2021/09/22/eoGf45ELCraPzJb.png)\r\n​        使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址， 在对象被移动（垃圾收集时移动对象是非常普遍的行为） 时只会改变句柄中的实例数据指针， 而reference本身不需要被修改。\r\n\r\n\r\n\r\n2. 通过直接指针\r\n\r\n![image-20210910195809240.png](https://i.loli.net/2021/09/22/yJBtTqNeEjnxmC4.png)\r\n\r\n​        用直接指针来访问最大的好处就是速度更快， 它节省了一次指针定位的时间开销，HotSpot也是主要使用这种方式来访问对象。\r\n\r\n\r\n\r\n## 3. 垃圾收集\r\n\r\n\r\n\r\n### 3.1 对象已死？\r\n\r\n​        垃圾收集器对堆进行回收之前，第一件事就是要确定哪些对还存活，哪些已经死去。\r\n\r\n\r\n\r\n#### 3.1.1 引用计数法\r\n\r\n​        在对象中添加一个引用计数器，每有一个地方引用它时，计数器就加一，当引用失效时，计数器就减一；当计数器为0时就是这个对象不能被使用了。但是当两个对象再无任何引用，实际上这两个对象已经不能再被使用，但是它们互相引用着对方，导致它们的计数器都不为0，引用计数法就无法回收它们。\r\n\r\n\r\n\r\n#### 3.1.2 可达性分析算法\r\n\r\n​        这个算法的基本思路就是通过叫做**“GC ROOTS**”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，如果某个对象不能被搜索到，就是说从GC ROOTS到这个对象不可达，则说明该对象是不能再被使用的。\r\n\r\n​        在Java中，可以作为GC ROOTS的对象包括以下几钟：\r\n\r\n​           - 在虚拟机栈中引用的对象\r\n\r\n​           - 在方法区中静态属性引用的对象\r\n\r\n​           - 在方法区中常量引用的对象\r\n\r\n​           - 本地方法栈中JNI引用的对象\r\n\r\n> Java对引用的概念进行了扩充， 将引用分为强引用（Strongly Re-ference） 、 软引用（Soft Reference） 、 弱引用（Weak Reference） 和虚引用（Phantom Reference） 4种， 这4种引用强度依次逐渐减弱。\r\n>\r\n> - 强引用是最传统的“引用”的定义， 是指在程序代码之中普遍存在的引用赋值， 即类似“Objectobj=new Object()”这种引用关系。 无论任何情况下， 只要强引用关系还存在， 垃圾收集器就永远不会回收掉被引用的对象。\r\n> - 软引用是用来描述一些还有用， 但非必须的对象。 只被软引用关联着的对象， 在系统将要发生内存溢出异常前， 会把这些对象列进回收范围之中进行第二次回收， 如果这次回收还没有足够的内存，才会抛出内存溢出异常。 在JDK 1.2版之后提供了SoftReference类来实现软引用。\r\n> - 弱引用也是用来描述那些非必须对象， 但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。 在JDK 1.2版之后提供了WeakReference类来实现弱引用。\r\n> - 虚引用也称为“幽灵引用”或者“幻影引用”， 它是最弱的一种引用关系。 一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 在JDK 1.2版之后提供了PhantomReference类来实现虚引用。\r\n\r\n\r\n\r\n### 3.2 垃圾收集算法\r\n\r\n\r\n\r\n#### 3.2.1 标记-清除算法\r\n\r\n​        回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。\r\n\r\n​        该算法主要有两个缺点：第一个是执行效率不稳定， 如果Java堆中包含大量对象， 而且其中大部分是需要被回收的， 这时必须进行大量标记和清除的动作， 导致标记和清除两个过程的执行效率都随对象数量增长而降低； 第二个是内存空间的碎片化问题， 标记、 清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。  \r\n\r\n\r\n\r\n#### 3.2.2 复制算法\r\n\r\n​        它将可用内存按容量划分为大小相等的两块，每次只是用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉。这种复制回收算法的代价是将可用内存缩小为了原来的一半， 空间浪费未免太多了一点。而且如果对象存活率较高时就会进行较多的复制操作，效率将会降低。  \r\n\r\n\r\n\r\n#### 3.2.3 标记-整理算法\r\n\r\n​        该算法其中的标记过程与标记-整理算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都移动到内存空间另一端，然后直接清理掉边界意外的内存。\r\n\r\n​        如果移动存活对象， 尤其是在老年代这种每次回收都有大量对象存活区域， 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作， 而且这种对象移动操作必须全程暂停用户应用程序才能进行。（Stop The World）  \r\n\r\n\r\n\r\n### 3.3 HotSpot的算法细节\r\n\r\n\r\n\r\n#### 3.3.1 根节点枚举\r\n\r\n​        所有收集器在根节点枚举这一步骤都是必须暂时用户线程的（STW），现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但是根节点枚举必须在一个能保障一致性的快照（在枚举期间整个程序就像是被冻结在某个时间点上）才得以进行。所以导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是像CMS、G1、ZGC这样的收集器，枚举根节点也是必须暂停的。\r\n\r\n​        当用户现场停顿下来时，其实并不需要一个不漏地检查完所有执行上下文和全局地引用位置，在HotSpot中，是使用`OopMap`来完成这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正地一个不漏地GCROOTS开始查找。\r\n\r\n\r\n\r\n#### 3.3.2 安全点\r\n\r\n​        在OopMap的协助下， HotSpot可以快速准确地完成GC Roots枚举， 但一个很现实的问题随之而来： 可能导致引用关系变化， 或者说导致OopMap内容变化的指令非常多， 如果为每一条指令都生成对应的OopMap， 那将会需要大量的额外存储空间， 这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。\r\n\r\n​        实际上HotSpot也的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）。\r\n\r\n\r\n\r\n#### 3.3.3 记忆集与卡表\r\n\r\n​        为了解决对象跨代引用所带来地问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GCROOTS扫描范围。\r\n\r\n> 对象跨代引用\r\n>\r\n> ​        跨代引用是指新生代中存在对老年代对象的引用，或者老年代中存在对新生代的引用。YGC时，为了找到年轻代中的存活对象，不得不遍历整个老年代；反之亦然。这种方案存在极大的性能浪费。\r\n\r\n​        记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。\r\n\r\n​        **卡表**是HotSopt实现记忆集的方式，卡表是一个字节数组，字节数组的每一个元素都对应着其标识的内存区域中一块特定大小的内存块。这个内存块被称作**卡页**。\r\n\r\n​        一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针， 那就将对应卡表的数组元素的值标识为1，称为这个**元素变脏**，没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。\r\n\r\n\r\n\r\n#### 3.3.4 并发的可达性分析\r\n\r\n​        **三色标记**\r\n\r\n​		白色：表示对象尚未被垃圾收集器访问过。在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍是白     色的对象，则代表不可达。\r\n\r\n​		黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的。黑色对象不可能直接指向（经过灰色对象）某个白色对象。\r\n\r\n​		灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。\r\n\r\n​		如果收集器与用户线程并发执行，收集器在对象图上标记颜色，同时用户线程在修改引用关系，这样可能会出现两种后果。一种是把原本消亡的对象错误标记为存活，这样其实是可以容忍的，下此收集清理掉就好。另一种是把原本存活的对象错误标记为已消亡，程序肯定会因此发生错误。\r\n\r\n![image-20210911134919993.png](https://i.loli.net/2021/09/22/JNRq8o34ewYZ7b2.png)\r\n\r\n​		当且仅当两种条件同时满足时，黑色的对象会被误标为白色：\r\n\r\n​				1.多了一条或多条 从黑色对象到白色对象的新引用\r\n\r\n​				2.删除了全部从灰色对象到该白色对象的直接或间接引用。\r\n\r\n​		因此，只要破坏到这个条件其中之一，就可以解决并发扫描时的对象消失问题。由此分别由两种解决方案：**增量更新**和**原始快照**。\r\n\r\n​		**增量更新**是要破坏第一个条件，当黑色对象插入新的白色对象的引用时，就将这个新插入的引用记录下来，等到并发扫描结束时，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。即**黑色对象一旦新插入了指向白色对象的引用之后，它就便会灰色对象。**\r\n\r\n​		**原始快照**要破坏的时第二个条件，当灰色对象要删除指向白色对象的引用时，就将这个要删除的引用记录下来，在并发扫描结束后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。即**无论引用是否删除，都会按照刚刚开始扫描的那一刻的对象图来进行搜索。**\r\n\r\n\r\n\r\n### 3.4 经典垃圾收集器\r\n\r\n\r\n\r\n#### 3.4.1 Serial收集器\r\n\r\n​		Serial收集器时最基础、历史最悠久的收集器。这是一个**单线程**工作的收集器，这不仅仅说明它只会使用一个处理器或一个收集线程区完成垃圾收集，更重要的时强调他在垃圾收集时，必须暂停其他所有工作线程。\r\n\r\n![image-20210911142240513.png](https://i.loli.net/2021/09/22/xdmIJ3iYszruA6B.png)\r\n\r\n#### 3.4.2 ParNew收集器\r\n\r\n​		ParNew收集器实质上是Serial收集器的多线程并行版本，采用复制算法，除了同时使用多条线程进行垃圾收集之外，其他的行为包括控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial收集器完全一致。并且可以和Serial一样（新生代），协同CMS进行垃圾收集。主要工作在 Young 区，整个过程都是 STW 的。\r\n\r\n![image-20210911142723328.png](https://i.loli.net/2021/09/22/F1wbPGm7r4AYT9N.png)\r\n\r\n#### 3.5.3 Parallel Scavenge收集器\r\n\r\n​		也是一款新生代收集器，同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。该收集器的关注点与其他收集器不同，目标是达到一个可控制的吞吐量：\r\n\r\n![image-20210911143503909.png](https://i.loli.net/2021/09/22/R74pdrvN3jtibc2.png)\r\n\r\n#### 3.5.4 Serial Old收集器\r\n\r\n​		Serial Old是Serial的老年代版本，同样是一个单线程收集器，使用**标记-整理**算法。\r\n\r\n![image-20210911142240513.png](https://i.loli.net/2021/09/22/xdmIJ3iYszruA6B.png)\r\n\r\n\r\n#### 3.5.5 Parallel Old收集器\r\n\r\n​		Parallel Old是Parallel Scavenge收集器的老年代版本， 支持多线程并发收集， 基于**标记-整理**算法实现。  \r\n\r\n![image-20210911143823371.png](https://i.loli.net/2021/09/22/Tp4YScD653X71Kd.png)\r\n\r\n#### 3.5.6 CMS\r\n\r\n​		CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收暂停时间为目标的收集器。CMS是基于**标记-清除**算法的。\r\n\r\n​		它的运作步骤包括四个阶段：\r\n\r\n​			    1.初始标记（STW）：仅仅标记一下GCROOTS能直接关联到的对象，速度很快\r\n\r\n​				2.并发标记：从GCROOTS的直接关联对象开始遍历整个对象图的过程，耗时长但不需要暂停用户线程\r\n\r\n​				3.重新标记（STW）：为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象\r\n\r\n​				4.并发清除：清除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的  \r\n\r\n![image-20210911144416223.png](https://i.loli.net/2021/09/22/9JhWm4cyeHb1RgN.png)\r\n\r\n​		CMS的三个缺点：\r\n\r\n​				1.CMS在并发阶段，虽然不会暂停用户线程，但是会占用了一部分线程导致应用程序变慢。\r\n\r\n​				2.CMS无法处理“浮动垃圾”。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新				   的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一				   次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。\r\n\r\n​				3. CMS是基于标记-清除算法的，会有很多的内存碎片。\r\n\r\n\r\n\r\n#### 3.5.7 G1\r\n\r\n​		G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。\r\n\r\n​		Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 \r\n\r\n​		虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域的动态集合。G1收集器之所以能够建立可预测的我停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体地处理思路**是让G1收集器去跟踪各个Gegion里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region，这就是“Garbage First”名字的由来**。\r\n\r\n​		G1将堆分成多个独立的Region，里面存在的跨Region引用对象如何解决？G1收集器的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在那些卡页的范围之内。\r\n\r\n​		G1在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？首先要解决的是用户线程改变对象引用关系时，必须保证其不能打破原本地对象图结构，导致标记结果出现错误，对此，**CMS采用增量更新算法实现，而G1是通过原始快照来实现的**。此外，垃圾收集过程中，程序还在继续运行，就会产生新的对象，G1为每个Region设计了两个名为TAMS地指针，把Region中地一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象的地址都必须在这两个指针位置以上。G1默认这个地址以上的对象时存活的，不纳入回收范围。\r\n\r\n​		如果不区计算用户线程运行过程中的动作，G1的运作过程大致可划分为四个步骤：\r\n\r\n​				1.初始标记（STW）：仅仅只是标记一下GCROOTS能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发													  运行时，能够正确地在可用的Regio中分配新对象。\r\n\r\n​				2.并发标记：从GCROOTS开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。\r\n\r\n​				3.最终标记（STW）：用于处理并发阶段结束后一六下来的最后那少量的SATB（原始快照）记录。\r\n\r\n​				4.筛选回收（STW）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来													  制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对												      象复制到空的Region中，在清理掉整个就Region的全部空间，是由多条回收线程并行完成的。\r\n\r\n![image-20210913182035584.png](https://i.loli.net/2021/09/22/Rv2uA7xzmXkaEL4.png)\r\n\r\n\r\n\r\n## 4. 虚拟机类加载机制\r\n\r\n​		Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。\r\n\r\n\r\n\r\n### 4.1 类加载的时机\r\n\r\n​		一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Perparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。\r\n\r\n![image-20210913183421877.png](https://i.loli.net/2021/09/22/SXQJRg1mk8NqPWB.png)\r\n\r\n\r\n#### 4.1.1 加载\r\n\r\n​		加载阶段是整个类加载过程中的一个阶段。在加载阶段，Java虚拟机需要完成以下三件事情：\r\n\r\n​				1.通过一个类的全限定类名来获取定义此类的二进制字节流。\r\n\r\n​				2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\r\n\r\n​				3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。\r\n\r\n\r\n\r\n#### 4.1.2 验证\r\n\r\n​		验证是连接阶段的第一步，这一阶段是确保Class文件的字节流中包含的信息运行后不会危害虚拟机自身的安全。验证阶段大致上会完成下面四个阶段的校验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。\r\n\r\n\r\n\r\n#### 4.1.3 准备\r\n\r\n​		准备阶段为类中定义的变量（即静态变量）分配内存并设置类变量初始值的阶段。Java8及之后，类变量存放在Java堆中。\r\n\r\n​		\r\n\r\n#### 4.1.4 解析\r\n\r\n​		解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。\r\n\r\n​		在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 `com.Wanger` 类引用了 `com.Chenmo` 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 `com.Chenmo`。\r\n\r\n​		直接引用通过对符号引用进行解析，找到引用的实际内存地址。\r\n\r\n\r\n\r\n#### 4.1.5 初始化\r\n\r\n​		准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序中编写的去赋初值。\r\n\r\n\r\n\r\n### 4.2 类加载器\r\n\r\n\r\n\r\n#### 4.2.1 类与类加载器\r\n\r\n​		类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。即比较两个类是否“相等”，只有在这两个类是否由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要它们的类加载器不同，那这两个类就必定不相等。\r\n\r\n\r\n\r\n#### 4.2.2 双亲委派模型\r\n\r\n\r\n\r\n![image-20210913202734295.png](https://i.loli.net/2021/09/22/lWYS1v4JOVp9IyE.png)\r\n\r\n\r\n​		1.Bootstrap ClassLoader ，主要负责加载Java核心类库，%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。\r\n\r\n​		2.Extention ClassLoader，主要负责加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。\r\n\r\n​		3.Application ClassLoader ，主要负责加载当前应用的classpath下的所有类\r\n\r\n​		4.User ClassLoader ， 用户自定义的类加载器,可加载指定路径的class文件\r\n\r\n​		\r\n\r\n​		双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求，子加载器才会尝试去加载。\r\n\r\n> 双亲委派模型的好处\r\n>\r\n> ​		首先，**通过委派的方式，可以避免类的重复加载**，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。\r\n>\r\n> ​		另外，**通过双亲委派的方式，还保证了安全性**。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。\r\n>\r\n> ​		那么，就可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。\r\n\r\n\r\n\r\n​		双亲委派模的实现仅有十余行代码，全部集中在`java.lang.ClassLoader`的`loadClass()`方法中：\r\n\r\n```java\r\nprotected Class<?> loadClass(String name, boolean resolve)throws ClassNotFoundException {\r\n    synchronized (getClassLoadingLock(name)) {\r\n        // 首先，检查请求的类是否已经被加载过了\r\n        Class<?> c = findLoadedClass(name);\r\n        if (c == null) {\r\n            long t0 = System.nanoTime();\r\n            try {\r\n                if (parent != null) {\r\n                    c = parent.loadClass(name, false);\r\n                } else {\r\n                    c = findBootstrapClassOrNull(name);\r\n                }\r\n            } catch (ClassNotFoundException e) {\r\n                // 如果父类加载器抛出ClassNotFoundException\r\n                // 说明父类加载器无法完成加载请求\r\n            }\r\n\r\n            if (c == null) {\r\n                // 在父类加载器无法加载时\r\n                // 再调用本身的findClass方法来进行类加载\r\n                long t1 = System.nanoTime();\r\n                c = findClass(name);\r\n            }\r\n        }\r\n        if (resolve) {\r\n            resolveClass(c);\r\n        }\r\n        return c;\r\n    }\r\n}\r\n```\r\n\r\n​		先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父加载器加载失败，抛出ClassNotFoundException的话。才调用自己的findClass()方法尝试加载。\r\n\r\n\r\n\r\n> 破坏双亲委派模型\r\n>\r\n> ​		重写loadClass(),不让它去委托父加载器\r\n\r\n​		\r\n\r\n## 5. Java内存模型与线程\r\n\r\n\r\n\r\n### 5.1 硬件的效率与一致性\r\n\r\n​		由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓存：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中，这样处理器就无需等待缓慢的内存读写了。\r\n\r\n​		高速缓存然后解决了处理器与内存速度间的矛盾，但是也引入了一个新的问题：缓存一致性。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及同一块内存区域时，将可能导致各自的缓存数据不一致。\r\n\r\n![image-20210913214904416.png](https://i.loli.net/2021/09/22/ORdnWylFjcrGht9.png)\r\n\r\n​		除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与顺序代码中的顺序一致。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有指令重排序优化。\r\n\r\n\r\n\r\n### 5.2 Java内存模型\r\n\r\n\r\n\r\n#### 5.2.1 主内存与工作内存\r\n\r\n​		Java内存模型的主要目的是定义程序中各种变量（包括实例字段、静态字段和构成数组对象的元素）的访问规则，即关注在虚拟机中把变量值存储到内存和内存中取出变量值这样的底层细节。\r\n\r\n​		Java内存模型规定了所有的变量都存储在主内存中。每条线程都有自己的工作内存，线程的工作内存中保存了该线程使用的变量的主内存副本，线程对所有的变量进行的所有操作都必须在工作内存中进行，而不能直接在主内存中操作。不同的线程之间也无法访问对方工作内存中的变量。线程间变量的传递需要通过主内存来完成。\r\n\r\n\r\n\r\n#### 5.2.2 volatile\r\n\r\n​		volatile关键字可以说是Java虚拟机提供的最轻量级的同步机制。\r\n\r\n​		当一个变量被定义为volatile之后，它将具备两个特性：第一项是保证此变量对所有线程的可见性，这里的“可见性”指的是**当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量的值在线程间的传递是要通过主内存才能完成。**\r\n\r\n> 当线程在自己的工作内存中更改volatile变量后，会立刻将该值写回主内存，该操作会让其它线程的工作内存中的该变量副本就会失效，需要重新从主内存中读取新值。\r\n\r\n​		volatile不能保证原子性。\r\n\r\n​		volatile的第一个语义是禁止指令重排，普通变量不能保证执行顺序与顺序执行的结果一致。volatile修饰的变量进行写操作时会在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障。\r\n\r\n![image-20210914162138186.png](https://i.loli.net/2021/09/22/trciACV9YFKuIBT.png)\r\n\r\n![image-20210914162208381.png](https://i.loli.net/2021/09/22/xYa6FePgXWZGImc.png)', 'https://s2.loli.net/2022/03/07/XsV9ugy1qmNk64L.png', '原创', 2, 0, 0, 0, 1, 1, '2022-03-07 10:53:45', '2021-09-22 05:34:11', 'JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码）.....', 1, 1);
INSERT INTO `t_blog` VALUES (2, '网络IO', '# IO\r\n\r\n## 前言\r\n\r\n### 计算机是如何运行的\r\n\r\ncpu\r\n\r\n内存\r\n\r\nio设备：网卡 硬盘（内核）  键盘鼠标\r\n\r\n\r\n\r\n开机，首先内核从硬盘（其实就是文件）加载进内存（内核其实就是一个程序，管理了所有的io设备。内核就是位于硬件和软件之间的一个管理层）\r\n\r\n\r\n\r\n内核被加载进内存，cpu执行指令，内核会把内核所在的地址空间置为内核空间（dgt），将剩余的空间化为用户空间，保护模式（在内核空间中的指令可以访问整个内存的任何地址，而在用户空间中的指令是禁止访问内核空间的）\r\n\r\n\r\n\r\n此时用户要使用外设，就必然要访问内核空间，但是又有保护模式，怎么办？\r\n\r\n#### 中断\r\n\r\n##### 软中断\r\n\r\n程序使用系统调用（软中断由软件产生），当正在执行一个程序时，需要访问内核空间中的方法，就会发生系统调用，保护用户程序的现场，访问内核中的地址，加载进cpu执行。（用户态到内核态的切换）\r\n\r\n\r\n\r\n##### 硬中断\r\n\r\n硬中断由硬件产生 时钟中断（晶振）假设是单核的cpu，用户程序中没有让出cpu的指令，而且是一个死循环，cpu就一直执行，就会耗死cpu。  晶振震动，然后传给cpu，cpu就不执行正在执行的程序，然后cpu将寄存器里的值写回内存（保护现场），中断处理程序（就是中断之后cpu要做的事），然后恢复现场，执行，然后晶振再震动......\r\n\r\n虽然进程增多，保护现场、恢复现场的次数会增多（数据拷贝等操作），损耗就会增多，cpu浪费在内核调度上的时间变多，执行程序的时间就会越少\r\n\r\n\r\n\r\n\r\n\r\n## 网络通信io的演变过程\r\n\r\n### BIO\r\n\r\nBlocking IO\r\n\r\n#### 操作系统层面\r\n\r\n首先程序调用socket系统调用，绑定端口号，listen（开启监听），然后accept（接受客户端连接），如果没有客户端连接，会阻塞，直到有客户端连接，然后开始recv接受客户端数据，这个如果没有数据发来，也会阻塞。\r\n\r\n然后我们可以开启多个线程来接受多个客户端。当有客户端连接，就给该客户端new一个新的Thread来处理，处理完后就销毁线程\r\n\r\n\r\n\r\n本质：accept和recv会阻塞\r\n\r\n![image-20210415193005211.png](https://i.loli.net/2021/04/15/ziPdj4qB1FSaCQW.png)\r\n\r\n\r\n#### Java BIO\r\n\r\n```java\r\npublic class BIOServer {\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket serverSocket = new ServerSocket(8888);  //相当于socket() 然后 bind(8888)\r\n        System.out.println(\"服务器准备就绪...\");\r\n        while (true) {\r\n            try {\r\n                // 阻塞方法获取新的连接\r\n                Socket socket = serverSocket.accept();  //accept();\r\n                // 每一个新的连接都创建一个线程，负责读取数据\r\n                new Thread(() -> {\r\n                    //recv\r\n                    try {\r\n                        int len;\r\n                        byte[] data = new byte[1024];\r\n                        InputStream inputStream = socket.getInputStream();\r\n                        // 按字节流方式读取数据\r\n                        while ((len = inputStream.read(data)) != -1) {\r\n                            System.out.println(new String(data, 0, len));\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }).start();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n```java\r\npublic class BIOClient {\r\n    public static void main(String[] args) {\r\n        new Thread(()->{\r\n            try {\r\n                Socket socket = new Socket(\"127.0.0.1\", 8888);  //和服务器建立连接\r\n                while (true) {\r\n                    socket.getOutputStream().write((Thread.currentThread().getName() + \" : \" + new Date() + \" hello world\").getBytes());\r\n                    Thread.sleep(2000);  //每2s连接一个\r\n                }\r\n            } catch (IOException | InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### NIO\r\n\r\n#### 操作系统 NIO nonblocking IO\r\n\r\n所有io操作的前三步都是一样的，首先socket，然后绑定端口，开启监听，然后nonblocking是调用了内核层的api，将accept设为了nonblocking非阻塞，此时server接受客户端连接不会阻塞，如果有连接接返回，没有就返回-1，然后接收到recv读取数据，将这个也设为了nonblocking，有数据就读取，否则直接返回-1\r\n\r\n弊端：如果1w个客户端，每个客户端都去查询，时间复杂度O（n），向内核发送O（n）次系统调用，如果只有小部分的客户端发送了数据，那么大部分的客户端不需要处理，相当于浪费了\r\n\r\n![image-20210415193227580.png](https://i.loli.net/2021/04/15/Cad5MAIXRtEUh4J.png)\r\n\r\n\r\n#### Java NIO New IO\r\n\r\nhttps://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-buffer.html\r\n\r\n面向通道和缓冲区的，数据总是从通道中读到buffer缓冲区内，或者从buffer写入到通道中。\r\n\r\n\r\n\r\nJava NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。\r\n\r\n\r\n\r\nNIO包含下面几个核心的组件：\r\n\r\n- Channels\r\n- Buffers\r\n- Selectors\r\n\r\n##### 通道和缓冲区（Channels and Buffers）\r\n\r\n通常来说NIO中的所有IO都是从Channel开始的。Channel和流有点类似。通过Channel，我们即可以从Channel把数据写到Buffer中，也可以把数据冲Buffer写入到Channel\r\n\r\n\r\n![overview-channels-buffers.png](https://i.loli.net/2021/04/15/UuHr6V4cMKd9Qel.png)\r\n\r\n\r\n\r\n##### 选择器（Selectors）\r\n\r\n通过Selector我们可以实现单线程操作多个channel。如果你的程序中有大量的连接，同时每个连接的IO带宽不高的话，这个特性将会非常有帮助。比如聊天服务器。 下面是一个单线程中Slector维护3个Channel的示意图：\r\n\r\n\r\n\r\n![overview-selectors.png](https://i.loli.net/2021/04/15/i7mkZ1BrLMxv2EN.png)\r\n\r\n\r\n```java\r\npackage nio;\r\n\r\nimport java.net.InetSocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.ServerSocketChannel;\r\nimport java.nio.channels.SocketChannel;\r\nimport java.util.LinkedList;\r\n\r\npublic class SocketNIO {\r\n    public static void main(String[] args) throws Exception {\r\n        //SocketChannel用于TCP的数据读写 相当于Java网络编程中的Socket套接字接口。\r\n        LinkedList<SocketChannel> clients = new LinkedList<>();\r\n\r\n        //ServerSocketChannel允许我们监听TCP连接请求，每个请求会创建会一个SocketChannel. 正如Java网络编程中的ServerSocket一样\r\n        ServerSocketChannel ss = ServerSocketChannel.open();\r\n        ss.bind(new InetSocketAddress(9090));\r\n        ss.configureBlocking(false);  //操作系统中的NONBlocking  //false非阻塞 true阻塞  accept()是否阻塞\r\n\r\n        while (true) {\r\n            //接受客户端的连接\r\n            Thread.sleep(1000);\r\n            SocketChannel client = ss.accept(); //不会阻塞  没有连接返回-1(NULL)\r\n\r\n            if (client == null) {\r\n                System.out.println(\"null......\");\r\n            } else {\r\n                client.configureBlocking(false); //非阻塞 客户端连接非阻塞 读数据时有数据直接读到  没有也不会阻塞 返回-1\r\n                int port = client.socket().getPort();\r\n                System.out.println(\"client...port\" + port);\r\n                clients.add(client);\r\n            }\r\n\r\n            //分配内存4096字节   allocate是分配在JVM中  allocateDirect在JVM外\r\n            //首先开辟一个Buffer 从SocketChannel中读取的数据放到Buffer中\r\n            ByteBuffer buffer = ByteBuffer.allocateDirect(4096);\r\n\r\n            for (SocketChannel c : clients) {\r\n                int num = c.read(buffer); //从channel中写数据到buffer  //read()方法的返回值是一个int数据，代表此次有多少字节的数据被写入了Buffer中。如果返回的是-1,那么意味着通道内的数据已经读取完毕，到底了（连接关闭）。\r\n                if (num > 0) {\r\n                    //翻转  将Buffer从写模式切换到读模式\r\n                    buffer.flip();\r\n                    byte[] aaa = new byte[buffer.limit()]; //在写模式，limit的含义是我们所能写入的最大数据量。它等同于buffer的容量。一旦切换到读模式，limit则代表我们所能读取的最大数据量\r\n                    buffer.get(aaa);  //从buffer读取数据\r\n\r\n                    String str = new String(aaa);\r\n                    System.out.println(c.socket().getPort() + \" : \" + str);\r\n                    buffer.clear();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### IO复用\r\n\r\n> 多路复用 返回io是否就绪，读数据时程序自己完成的，所以这种io模型还是同步io\r\n\r\nio多路复用，一个进程可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行响应的读写操作\r\n\r\n\r\n\r\n首先还是基本的三步，socket()，bind()，listen()，然后\r\n\r\n\r\n\r\n将多个客户端的请求封装在一个多路复用器，然后去请求（O（1））一次系统调用，然后内核返回具体有多少（m）个可用的，复杂度就是O（m）\r\n\r\n相当于很多io复用了这一次系统调用，然后内核返回给你一个具体的可用状态，但是读写还是要客户端程序自己完成（同步）(自己去系统调用)\r\n\r\n此时是内核去遍历（O（n））\r\n\r\n![image-20210415200701027.png](https://i.loli.net/2021/04/15/wq3LbO9d2UNTQ4K.png)\r\n\r\n\r\n> Select会将全量`fd_set`从用户空间拷贝到内核空间，并注册回调函数， 在内核态空间来判断每个请求是否准备好数据 。select在没有查询到有文件描述符就绪的情况下，将一直阻塞（I/O多路复用中提过：select是一个阻塞函数）。如果有一个或者多个描述符就绪，那么select将就绪的文件描述符置位，然后select返回。返回后，由程序遍历查看哪个请求有数据。\r\n>\r\n> **Select的缺陷**\r\n>\r\n> - 每次调用select，都需要把fd集合从用户态拷贝到内核态，fd越多开销则越大（内核对这些fds没有缓存，所以要重复传递）；\r\n> - 每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大\r\n> - select支持的文件描述符数量有限，默认是1024。\r\n\r\nselect它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。（bitmap 1024 不可重用）\r\n\r\n![image-20201214131625726.png](https://i.loli.net/2021/04/15/j7yJScLPeONhZob.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n> poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用`pollfd`结构代替select的`fd_set`结构，其他的本质上都差不多。所以**Poll机制突破了Select机制中的文件描述符数量最大为1024的限制**。\r\n>\r\n> **Poll的缺陷**\r\n>\r\n> Poll机制相较于Select机制中，解决了文件描述符数量上限为1024的缺陷。但另外两点缺陷依然存在：\r\n>\r\n> - 每次调用poll，都需要把fd集合从用户态拷贝到内核态，fd越多开销则越大（内核对这些fds没有缓存，所以要重复传递）；\r\n> - 每次调用poll，都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大\r\n\r\npoll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是基于链表来存储的（pollfd无限制）\r\n\r\n![image-20201214132117908.png](https://i.loli.net/2021/04/15/dI54r32mgcRZB9A.png)\r\n\r\n\r\nselect，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升\r\n\r\n![image-20210415200828845.png](https://i.loli.net/2021/04/15/KMFV1RnhiD7ZdNr.png)\r\n\r\n\r\n> epoll操作过程需要上述三个函数，也正是通过三个函数完成Select机制中一个函数完成的事情，解决了Select机制的三大缺陷。epoll的工作机制更为复杂，我们就解释一下，它是如何解决Select机制的三大缺陷的。\r\n>\r\n> 1. 对于第一个缺点，epoll的解决方案是：它的**fd是共享在用户态和内核态之间**的，所以可以不必进行从用户态到内核态的一个拷贝，大大节约系统资源。至于如何做到用户态和内核态，大家可以查一下“**mmap**”，它是一种内存映射的方法。\r\n> 2. 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把当前线程轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把当前线程挂一遍（这一遍必不可少），并为每个fd指定一个回调函数。当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而**这个回调函数会把就绪的fd加入一个就绪链表。那么当我们调用epoll_wait时，epoll_wait只需要检查链表中是否有存在就绪的fd即可，效率非常可观**。\r\n> 3. 对于第三个缺点，fd数量的限制，也只有Select存在，Poll和Epoll都不存在。由于Epoll机制中只关心就绪的fd，它相较于Poll需要关心所有fd，在连接较多的场景下，效率更高。在1GB内存的机器上大约是10万左右，一般来说这个数目和系统内存关系很大。\r\n\r\nselect，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。 \r\n\r\n\r\n\r\nselect poll 都是内核需要将消息传递到用户空间，都需要内核拷贝动作\r\n\r\n\r\n\r\nepoll通过内核和用户空间共享一块内存来实现的。\r\n\r\n\r\n\r\nhttps://www.cnblogs.com/aspirant/p/9166944.html\r\n\r\nhttps://www.cnblogs.com/anker/p/3265058.html\r\n\r\n\r\n\r\n\r\n\r\n### Reactor\r\n\r\n#### 单线程\r\n\r\n![1485398-20181022232217633-124484857.jpg](https://i.loli.net/2021/04/15/opjcInCiJFwfYHW.jpg)\r\n\r\n- **Reactor**将I/O事件分派给对应的Handler\r\n- **Acceptor**处理客户端新连接，并分派请求到处理器链中\r\n- **Handlers**执行非阻塞读/写 任务\r\n\r\n当其中某个 handler 阻塞时， 会导致其他所有的 client 的 handler 都得不到执行， 并且更严重的是， handler 的阻塞也会导致整个服务不能接收新的 client 请求(因为 acceptor 也被阻塞了)。 因为有这么多的缺陷， 因此单线程Reactor 模型用的比较少。这种单线程模型不能充分利用多核资源，所以实际使用的不多。\r\n\r\n\r\n\r\n#### 多线程\r\n\r\n##### 单Reactor\r\n\r\n在线程Reactor模式基础上，做如下改进：\r\n\r\n（1）将Handler处理器的执行放入线程池，多线程进行业务处理。\r\n\r\n\r\n\r\n![1485398-20181022232219420-1734756772.png](https://i.loli.net/2021/04/15/O81qRWGncMEzajT.png)\r\n\r\n\r\n\r\n\r\n##### 双Reactor\r\n\r\n对于Reactor而言，可以仍为单个线程。如果服务器为多核的CPU，为充分利用系统资源，可以将Reactor拆分为两个线程。\r\n\r\n![image-20210415203019649.png](https://i.loli.net/2021/04/15/hfU2WNF3MjxCyLv.png)\r\n- mainReactor负责监听server socket，用来处理新连接的建立，将建立的socketChannel指定注册给subReactor。\r\n- subReactor维护自己的selector, 基于mainReactor 注册的socketChannel多路分离IO读写事件，读写网络数据，对业务处理的功能，另其扔给worker线程池来完成。\r\n\r\n\r\n\r\n我们可以看到，mainReactor 主要是用来处理网络IO 连接建立操作，通常一个线程就可以处理，而subReactor主要做和建立起来的socket做数据交互和事件业务处理操作，它的个数上一般是和CPU个数等同，每个subReactor一个线程来处理。\r\n\r\n\r\n\r\n\r\n\r\nhttps://www.cnblogs.com/crazymakercircle/p/9833847.html\r\n\r\nhttps://juejin.cn/post/6844903636422623240#heading-6\r\n\r\nhttps://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect', 'https://sm.ms/image/GhJuLkysEct4FV2', '原创', 46, 1, 1, 1, 1, 1, '2021-09-22 05:45:56', '2021-09-22 05:45:56', '网络IO......', 3, 1);
INSERT INTO `t_blog` VALUES (13, 'JWT', '# JWT\r\n\r\nJson Web Token\r\n\r\n\r\n\r\n## jwt是什么？\r\n\r\nJson web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。\r\n\r\n\r\n\r\n## 为什么要使用jwt？\r\n\r\n### session\r\n\r\n我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。\r\n\r\n\r\n\r\n![640.png](https://i.loli.net/2021/09/24/tyXvfi1Pq3KuCQw.png)\r\n\r\n\r\n\r\n1. 用户向服务器发送用户名和密码用于登陆系统。\r\n2. 服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储 起来。\r\n3. 服务器向用户返回一个 SessionID，写入用户的 Cookie。\r\n4. 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。\r\n5. 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。\r\n\r\n\r\n\r\n但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.\r\n\r\n#### 问题\r\n\r\n**Session**: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。\r\n\r\n**扩展性**: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。\r\n\r\n**CSRF**: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。\r\n\r\n\r\n\r\n### 基于token的鉴权机制\r\n\r\n基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。\r\n\r\n流程上是这样的：\r\n\r\n- 用户使用用户名密码来请求服务器\r\n- 服务器进行验证用户的信息\r\n- 服务器通过验证发送给用户一个token\r\n- 客户端存储token，并在每次请求时附送上这个token值\r\n- 服务端验证token值，并返回数据\r\n\r\n这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持`CORS(跨来源资源共享)`策略，一般我们在服务端这么做就可以了`Access-Control-Allow-Origin: *`。\r\n\r\n\r\n\r\n## jwt的组成\r\n\r\n第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).\r\n\r\n\r\n\r\n### header\r\n\r\njwt的头部承载两部分信息：\r\n\r\n- 声明类型，这里是jwt\r\n- 声明加密的算法 通常直接使用 HMAC SHA256\r\n\r\n完整的头部就像下面这样的JSON：\r\n\r\n```json\r\n{\r\n  \'typ\': \'JWT\',\r\n  \'alg\': \'HS256\'\r\n}\r\n```\r\n\r\n然后用 `Base64Url` 编码得到头部`xxxxx`\r\n\r\n\r\n\r\n\r\n\r\n### playload\r\n\r\n载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分\r\n\r\n- 标准中注册的声明\r\n- 公共的声明\r\n- 私有的声明\r\n\r\n**标准中注册的声明** (建议但不强制使用) ：\r\n\r\n- **iss**: jwt签发者\r\n- **sub**: jwt所面向的用户\r\n- **aud**: 接收jwt的一方\r\n- **exp**: jwt的过期时间，这个过期时间必须要大于签发时间\r\n- **nbf**: 定义在什么时间之前，该jwt都是不可用的.\r\n- **iat**: jwt的签发时间\r\n- **jti**: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\r\n\r\n**公共的声明** ：\r\n 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.**但不建议添加敏感信息，因为该部分在客户端可解密.**\r\n\r\n**私有的声明** ：\r\n 私有声明是提供者和消费者所共同定义的声明，**一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。**\r\n\r\n定义一个payload:\r\n\r\n```json\r\n{\r\n  \"sub\": \"1234567890\",\r\n  \"name\": \"John Doe\",\r\n  \"admin\": true\r\n}\r\n```\r\n\r\n将上面的 `json` 进行 `Base64Url` 编码得到载荷，得到Jwt的第二部分`yyyyy`\r\n\r\n\r\n\r\n\r\n\r\n### signature\r\n\r\n签名时需要用到前面编码过的两个字符串，如果以 `HMACSHA256` 加密，就如下：\r\n\r\n```javascript\r\nHMACSHA256(\r\n    base64UrlEncode(header) + \".\" +\r\n    base64UrlEncode(payload),\r\n    secret\r\n)\r\n```\r\n\r\n加密后再进行 `base64url` 编码最后得到的字符串就是 `token` 的第三部分`zzzzz`。\r\n\r\n组合便可以得到 `token：xxxxx.yyyyy.zzzzz`。\r\n\r\n> 签名的作用：保证 JWT 没有被篡改过，原理如下：\r\n>\r\n> HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先共享的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。\r\n\r\n\r\n\r\n在基于 Token 进行身份验证的的应用程序中，服务器通过`Payload`、`Header`和一个密钥(`secret`)创建令牌（`Token`）并将 `Token` 发送给客户端，客户端将 `Token` 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：`Authorization: Bearer Token`。\r\n\r\n> 一般是在请求头里加入`Authorization`，并加上`Bearer`标注：\r\n>\r\n> ```javascript\r\n> fetch(\'api/user/1\', {\r\n>    headers: {\r\n>      \'Authorization\': \'Bearer \' + token\r\n>    }\r\n> })\r\n> ```\r\n\r\n\r\n\r\nJWT 在客户端的存储有三种方式：\r\n\r\n- LocalStorage\r\n- SessionStorage\r\n- Cookie [不能设置 HTTPonly（js无法读取设置了httponly的cookie）]\r\n\r\n但是最推荐的还是第三种，因为第一二种存在跨域读取限制，而 Cookie 使用不同的跨域策略\r\n\r\n因为没开 HTTPonly，所以要注意防范 XSS 漏洞。\r\n\r\n> Cookie 的跨域策略\r\n>\r\n> 子可以读父，但是父不可以读子，兄弟之间不能互相访问。\r\n>\r\n> a.xxx.com 和 b.xxx.com 可以读 xxx.com，但是 a.xxx.com 和 b.xxx.com 不能互相读取，xxx.com 也不能读 a.xxx.com 和 b.xxx.com 的。\r\n>\r\n> 你可能会想：存 Cookie 那我不是又变得和 cookie + session 一样了吗？\r\n>\r\n> 其实不然，因为存 cookie 在这只是用到了其存储机制，而没有利用其去鉴权。也就是说我只是简单存一下，并没有期望浏览器带上去 token 去鉴权，将 token 加入请求这部分操作还是我手动进行的。\r\n\r\n\r\n\r\n![614.png](https://i.loli.net/2021/09/24/raNGePK8JW5o2R6.png)\r\n\r\n\r\n\r\n\r\n\r\n## 怎样使用jwt？\r\n\r\nspringboot集成jwt\r\n\r\n首先maven `pom.xml`\r\n\r\n```xml\r\n <dependency>\r\n            <groupId>com.auth0</groupId>\r\n            <artifactId>java-jwt</artifactId>\r\n            <version>3.4.0</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n首先是JWTUtils，用来生成token和验证\r\n\r\n```java\r\npublic class JWTUtils {\r\n\r\n    /**\r\n     * 过期时间为一天\r\n     */\r\n    private static final long EXPIRE_TIME = 24*60*60*1000;\r\n\r\n    /**\r\n     * token私钥\r\n     */\r\n    private static final String TOKEN_SECRET = \"joijsdfjlsjfljfljl5135313135\";\r\n\r\n    public static String createToken(String username) {\r\n        //过期时间\r\n        Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME); //前面加上currentTimeMillis来保证每次生成的token不一样\r\n\r\n        //私钥及加密算法\r\n        Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);\r\n\r\n        //设置头信息\r\n        Map<String, Object> header = new HashMap<>(2);\r\n        header.put(\"typ\", \"JWT\");\r\n        header.put(\"alg\", \"HS256\");\r\n\r\n        String token = JWT.create().withHeader(header).withClaim(\"loginName\", username)\r\n                .withExpiresAt(date).sign(algorithm);  //withHeader是封装Token的header //withClaim是传入payload  //sign 是signature 签名\r\n\r\n        return token;\r\n    }\r\n\r\n    public static DecodedJWT verifyToken(String token) throws Exception {\r\n        Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);\r\n        JWTVerifier verifier = JWT.require(algorithm).build();\r\n        //DecodedJWT 将jwt解密 将xxx.yyy.zzz 分开\r\n        return verifier.verify(token);\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n然后写一个拦截器\r\n\r\n```java\r\npublic class JWTInterceptor implements HandlerInterceptor {\r\n\r\n    @Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n\r\n        try {\r\n            //这里token通过cookie传输\r\n            Cookie cookie = CookieUtils.get(request, \"token\");\r\n            String token = cookie.getValue();\r\n            JWTUtils.verifyToken(token);//验证token令牌\r\n            return true;  //放行\r\n        } catch (SignatureVerificationException e) {\r\n            e.printStackTrace();\r\n            System.out.println(\"无效签名\");\r\n        } catch (TokenExpiredException e) {\r\n            e.printStackTrace();\r\n            System.out.println(\"token过期\");\r\n        } catch (AlgorithmMismatchException e) {\r\n            e.printStackTrace();\r\n            System.out.println(\"token算法不一致\");\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            System.out.println(\"token无效\");\r\n        }\r\n        //将msg 发出去\r\n        CookieUtils.set(response, \"msg\", \"请先登录！\", -1);\r\n        response.sendRedirect(\"/admin\");\r\n        return false;  //拦截\r\n    }\r\n}\r\n```\r\n\r\n将拦截器`HandlerInterceptor`注册到spring中\r\n\r\n```java\r\n@Configuration\r\npublic class MVCConfig implements WebMvcConfigurer {\r\n\r\n    //后台管理的拦截器\r\n    @Override\r\n    public void addInterceptors(InterceptorRegistry registry) {\r\n        registry.addInterceptor(new JWTInterceptor())\r\n                .addPathPatterns(\"/admin/**\")\r\n                .excludePathPatterns(\"/admin\")\r\n                .excludePathPatterns(\"/admin/login\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n我这里使用的是cookie用来保存token\r\n\r\n> 关于cookie的一些细节：\r\n>\r\n> - 删除cookie  注销的时候是要删除存储token的cookie\r\n>\r\n>     注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。\r\n\r\n```java\r\npublic class CookieUtils {\r\n\r\n    public static void set(HttpServletResponse response, String name, String value, int maxAge) {\r\n        Cookie cookie = new Cookie(name, value);\r\n        cookie.setMaxAge(maxAge);\r\n        response.addCookie(cookie);\r\n    }\r\n\r\n    /*\r\n     注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。\r\n     否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。\r\n     */\r\n    public static void delete(HttpServletResponse response, String name) {\r\n        set(response, name, null, 0);\r\n    }\r\n\r\n    public static Cookie get(HttpServletRequest request, String name) {\r\n        Cookie[] cookies = request.getCookies();\r\n        if (cookies == null) {\r\n            return null;\r\n        }\r\n\r\n        for (Cookie cookie : cookies) {\r\n            if (cookie.getName().equals(name)) {\r\n                return cookie;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n接着在Controller中配置一下\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/admin\")\r\npublic class LoginController {\r\n\r\n    @Autowired\r\n    private UserService userService;\r\n\r\n    @GetMapping\r\n    public String loginPage(HttpServletRequest request, HttpServletResponse response) {\r\n        Cookie token = CookieUtils.get(request, \"token\");\r\n        if (token != null) {  //如果token没失效\r\n            return \"admin/index\";\r\n        }\r\n        return \"admin/login\";\r\n    }\r\n\r\n    @PostMapping(\"/login\")\r\n    public String login(String username, String password, HttpServletResponse response, RedirectAttributes attributes) {\r\n        User user = userService.check(username, MD5Utils.string2MD5(password));\r\n\r\n        if (user == null) {\r\n            attributes.addFlashAttribute(\"message\", \"用户名或密码错误\");\r\n            return \"redirect:/admin\";\r\n        }\r\n        //验证通过\r\n        //生成token\r\n        String token = JWTUtils.createToken(username);\r\n        //将token存储在cookie中\r\n        CookieUtils.set(response, \"token\", token, -1);\r\n        CookieUtils.set(response, \"username\", user.getUsername(), -1);\r\n        CookieUtils.set(response, \"avatar\", user.getAvatar(), -1);\r\n        CookieUtils.delete(response, \"msg\");\r\n        return \"admin/index\";\r\n    }\r\n\r\n    //\r\n    @GetMapping(\"/logout\")\r\n    public String logout(HttpServletResponse response) {\r\n        CookieUtils.delete(response, \"avatar\");\r\n        CookieUtils.delete(response, \"username\");\r\n        CookieUtils.delete(response, \"token\");\r\n        return \"redirect:/admin\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n', 'https://s2.loli.net/2022/03/07/4KkvCpcmE5YudVj.jpg', '原创', 1, 0, 0, 1, 1, 1, '2022-03-07 10:52:40', '2021-09-24 15:09:05', 'Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证...', 7, 1);
INSERT INTO `t_blog` VALUES (14, '关于TopK', '# 数组中的第K个最大元素\r\n\r\n在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\r\n\r\n示例 1:\r\n\r\n```\r\n输入: [3,2,1,5,6,4] 和 k = 2\r\n输出: 5\r\n```\r\n\r\n示例 2:\r\n\r\n```\r\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\r\n输出: 4\r\n```\r\n\r\n\r\n说明:\r\n\r\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\r\n\r\n\r\n\r\n## 解法1：\r\n\r\n**对整个数组进行排序**\r\n\r\n\r\n\r\n这里就不给出代码了\r\n\r\n\r\n\r\n## 解法2：\r\n\r\n**基于快速排序的快速选择**\r\n\r\n个人理解该解法的核心思想和快排的一致，可以说是不完全的快速排序\r\n\r\n首先我们先看快速排序的核心思想\r\n\r\n快排的核心就是选出一个基点pivot，然后用这个基点和数组中的其余数进行比较，使得比pivot小的都在它的左边，比它大的都在右边，这就是一趟排序的过程\r\n\r\n```java\r\nprivate int partition(int[] arr, int left, int right) {\r\n    int pivot = right;\r\n    int j = left;\r\n    for (int i = left; i < right; i++) {\r\n        if (arr[i] > arr[pivot]) {\r\n            swap(arr, i, pivot);\r\n            j++;\r\n        }\r\n    }\r\n    swap(arr, j, pivot);\r\n    return j;\r\n}\r\n```\r\n\r\n\r\n\r\n比如以这个数组为例 [8, 5, 1, 6, 2, 7, 3, 4]\r\n\r\n![image-20210418143142633.png](https://i.loli.net/2021/09/24/4KGStiwPyWRrXDY.png)\r\n\r\n\r\n一趟下来就发现比pivot小的在左边，比pivot大的在右边\r\n\r\n\r\n\r\n然后再对[left, pivot - 1]进行快排，[pivot + 1, right]也是如此，直到left >= right就停止\r\n\r\n```java\r\npublic void quickSort(int[] arr, int left, int right) {\r\n    if (left < right) {\r\n        int mid =  partition(arr, left, right);\r\n        quickSort(arr, left, mid - 1);\r\n        quickSort(arr, mid + 1, right);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n回到topK，发现只是求第k大个数，我们发现`partition(arr, left, right)`返回的是最终pivot的下标index，也就是说返回的下标index就是第index大的数，我们可以利用这个来完成快速选择，如果返回的下标index是刚好我们要求的k的话，那直接返回就ok，如果是index大于k的话（选择的是从大到小排序），那么说明要找的k在[pivot+1, right]中再去快速选择，如果小于k的话，那么就去[left, pivot-1]中快速选择\r\n\r\n```java\r\npublic int findKthLargest(int[] arr, int k) {\r\n    return quickSelect(arr, k - 1, 0, arr.length - 1);\r\n}\r\n\r\nprivate int quickSelect(int[] arr, int k, int left, int right) {\r\n    int res = partition(arr, left, right);\r\n    if (res == k) {\r\n        return arr[k];\r\n    }\r\n\r\n    return res > k ? quickSelect(arr, k, left, res - 1) : quickSelect(arr, k, res + 1, right);\r\n}\r\n\r\nprivate int partition(int[] arr, int left, int right) {\r\n    int pivot = right;\r\n    int j = left;\r\n    for (int i = left; i < right; i++) {\r\n        if (arr[i] > arr[pivot]) {\r\n            swap(arr, i, j);\r\n            j++;\r\n        }\r\n    }\r\n\r\n    swap(arr, j, pivot);\r\n    return j;\r\n}\r\n\r\nprivate void swap(int[] arr, int i, int j) {\r\n    int temp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = temp;\r\n}\r\n```\r\n\r\n\r\n\r\n### 解法3：\r\n\r\n**基于堆排序的选择方法**\r\n\r\n堆排序，这个解法的核心和堆排序也是一致的，采用的是大顶堆\r\n\r\n首先我们先看堆排序的核心思想\r\n\r\n我们需要构建一个大顶堆\r\n\r\n> **大顶堆**\r\n>\r\n> 堆其实就是一个完全二叉树，而大顶堆就是对于该完全二叉树来说，每个子树的root的值都是大于子结点的值的\r\n>\r\n> 这棵树就是一个完全二叉树\r\n>\r\n> ![image-20210418160208581.png](https://i.loli.net/2021/09/24/1rcaJgjWtEHp9ui.png)\r\n>\r\n> \r\n>\r\n> 下面的这颗就不是一个完全二叉树\r\n>\r\n> ![image-20210418162453934.png](https://i.loli.net/2021/09/24/h9JcGTjnNHLa4gD.png)\r\n\r\n\r\n\r\n数组堆化\r\n\r\n首先我们先来看一下有三个值的数组，如果对它构建一个完全二叉树就是\r\n\r\n![image-20210418164407882.png](https://i.loli.net/2021/09/24/L4Fvlkfx8QbXU1a.png)\r\n\r\n\r\n如果父节点的下标是i，那么其左子节点就是2 * i + 1，右子节点就是2 * i + 2，如果不是完全二叉树的话，这个关系就不成立了。\r\n\r\n其次我们使之成为一个大顶堆，就是在父节点还有左右子节点中选取一个最大的值，然后让这个最大的成为root（交换一下就可以）\r\n\r\n![image-20210418164603428.png](https://i.loli.net/2021/09/24/p29WjqrtZLvVmFY.png)\r\n\r\n然后我们在思考，如果这个数组不止有3个值，如果有更多的，那么树就不想这样简单了，然后我们在交换之后，可能会破坏以i=2为root的这棵完全二叉树，所以我们要对它递归的再去构建一下大顶堆。\r\n\r\n\r\n\r\n然后考虑到以上这些，我们只需要在数组中找到所有的parent节点，然后对他们构造即可，为了不破坏子树，我们应该从最后一个节点向上构建，也就是自底向上的构造，否则将会破坏已经构造好的子树，需要对其再次递归构造。\r\n\r\n\r\n\r\n接着构造好这个大顶堆后，我们将最后一个节点和根节点（也就是第一个节点）交换一下，最后一个节点就是最大的了，然后我们将最后一个节点排除在外，在对之前的节点构造一次大顶堆，接着就重复这个过程，就是一个排序的过程。\r\n\r\n\r\n\r\n大概理解了堆排序的思想，我们回到topk这个问题，很容易就想到，可以对堆排序就行一个简化，就是不用完全排序，只对前k个排序就行了。\r\n\r\n代码如下：\r\n\r\n```java\r\npublic class Topk {\r\n    public int topK(int[] arr, int k) {\r\n        buildHeap(arr);\r\n\r\n        for (int i = arr.length - 1; i > arr.length - k; i--) { //只需要k次\r\n            //第一个节点和最后一个节点交换\r\n            swap(arr, 0, i);\r\n            //当前堆被破坏，重新构造堆\r\n            heapify(arr, 0, i);\r\n        }\r\n\r\n        return arr[0];\r\n    }\r\n    \r\n\r\n    private void buildHeap(int[] arr) {\r\n        //首先找到最后一下父节点\r\n        int parent = (arr.length - 1) / 2;\r\n\r\n        //自底向上构建堆\r\n        for (int i = parent; i >= 0; i--) {\r\n            heapify(arr, i, arr.length);\r\n        }\r\n    }\r\n\r\n    private void heapify(int[] arr, int i, int len) { //i是parent节点的下标, len是要对多少个节点构建堆\r\n        int left = 2 * i + 1;\r\n        int right = 2 * i + 2;\r\n        int max = i;\r\n\r\n        if (left < len && arr[max] < arr[left]) {\r\n            max = left;\r\n        }\r\n\r\n        if (right < len && arr[max] < arr[right]) {\r\n            max = right;\r\n        }\r\n\r\n        if (max != i) {\r\n            swap(arr, max, i);\r\n\r\n            //对被破坏的子树重新构建大顶堆\r\n            heapify(arr, max, len);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n', 'https://s2.loli.net/2022/03/07/sObpRde14v39wBP.jpg', '原创', 5, 0, 0, 1, 1, 1, '2022-03-07 10:50:01', '2021-09-24 15:24:24', '关于topK问题的几种个人见解.....', 2, 1);
INSERT INTO `t_blog` VALUES (15, 'Spring Bean', '# Spring Bean\r\n\r\n在Spring中，由Spring Ioc容器管理的对象，成为bean。\r\n\r\n\r\n\r\n## bean的配置\r\n\r\n### xml\r\n\r\n```xml\r\n<bean id=\"beanName\" class=\"全限定类名\" />\r\n```\r\n\r\n\r\n\r\n### 注解\r\n\r\n首先在applicationContext.xml中开启包扫描\r\n\r\n```xml\r\n<context:component-scan base-package=\"com.yiqiandewo\" />\r\n```\r\n\r\n```java\r\n@Service(\"beanFactory\")\r\npublic class BeanFactroyImpl implements BeanFactory {\r\n    @Override\r\n    public void Beantest() {\r\n        System.out.println(\"This is a 基于Java注解的bean!\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### Java类配置\r\n\r\n```java\r\n@Configuration\r\npublic class BeanConfig {\r\n    @Bean\r\n    public BeanFactory beanFactory(){\r\n        return new BeanFactoryImpl();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 实例化\r\n\r\n\r\n\r\n### 构造函数\r\n\r\n当你通过构造函数的途径来实例化bean，**都需要为bean写上一个默认构造函数（如果构造函数带参数还需要定义一个不带参数的构造函数）**。\r\n\r\n\r\nxml配置文件：\r\n\r\n```xml\r\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\"/>\r\n\r\n<bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/>\r\n```\r\n\r\n\r\n\r\n### 静态方法\r\n\r\n通过定义这个bean是由静态工厂方法创建时，class属性是指向静态工厂类，而`factory-method`属性是指向这个工厂类实例化这个bean的静态方法。\r\n\r\n下面的bean定义就是通过静态工厂方法创建bean实例的，下面返回的对象是没有指定class（Object），仅仅是配置了工厂class和对应的工厂创建方法。下面的例子中，`createInstance()`方法必须要是静态的。\r\n\r\n```xml\r\n<bean id=\"clientService\"\r\n    class=\"examples.ClientService\"\r\n    factory-method=\"createInstance\"/>\r\n```\r\n\r\n```java\r\npublic class ClientService {\r\n    private static ClientService clientService = new ClientService();\r\n    private ClientService() {}\r\n    \r\n	public static ClientService createInstance() {\r\n        return clientService;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 实例工厂\r\n\r\n与静态工厂方法类似，**不同之处是调用的不是静态方法**。\r\n实例工厂方法的实例化从容器中调用一个现有bean的非静态方法来创建一个新bean。要使用这种机制，请将class属性留空，在工厂bean属性中，指定当前（或父/祖先）容器中的bean名称，该容器包含要调用的实例方法来创建对象。用工厂方法属性设置工厂方法本身的名称。\r\n\r\n```xml\r\n<!-- the factory bean, which contains a method called createInstance() -->\r\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\r\n    <!-- inject any dependencies required by this locator bean -->\r\n</bean>\r\n\r\n<!-- the bean to be created via the factory bean -->\r\n<bean id=\"clientService\"\r\n    factory-bean=\"serviceLocator\"\r\n    factory-method=\"createClientServiceInstance\"/>\r\n```\r\n\r\n```java\r\npublic class DefaultServiceLocator {\r\n    private static ClientService clientService = new ClientServiceImpl();\r\n\r\n    public ClientService createClientServiceInstance() {\r\n        return clientService;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n一个工厂类可以拥有多个工厂方法，如下所示：\r\n\r\n```xml\r\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\r\n    <!-- inject any dependencies required by this locator bean -->\r\n</bean>\r\n\r\n<bean id=\"clientService\"\r\n    factory-bean=\"serviceLocator\"\r\n    factory-method=\"createClientServiceInstance\"/>\r\n\r\n<bean id=\"accountService\"\r\n    factory-bean=\"serviceLocator\"\r\n    factory-method=\"createAccountServiceInstance\"/>\r\n```\r\n\r\n```java\r\npublic class DefaultServiceLocator {\r\n\r\n    private static ClientService clientService = new ClientServiceImpl();\r\n    private static AccountService accountService = new AccountServiceImpl();\r\n\r\n    private DefaultServiceLocator() {}\r\n\r\n    public ClientService createClientServiceInstance() {\r\n        return clientService;\r\n    }\r\n\r\n    public AccountService createAccountServiceInstance() {\r\n        return accountService;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 依赖注入\r\n\r\n### 基于构造函数的依赖注入\r\n\r\n基于构造函数的依赖注入是通过调用构造函数，通过传入一个或多个参数来实现的依赖注入。有点类似于静态工厂方法实例化bean。\r\n\r\n```java\r\npublic class SimpleMovieLister {\r\n\r\n    // the SimpleMovieLister has a dependency on a MovieFinder\r\n    private MovieFinder movieFinder;\r\n\r\n    // a constructor so that the Spring container can inject a MovieFinder\r\n    public SimpleMovieLister(MovieFinder movieFinder) {\r\n        this.movieFinder = movieFinder;\r\n    }\r\n\r\n    // business logic that actually uses the injected MovieFinder is omitted...\r\n}\r\n```\r\n\r\n注意，该类没有什么特别的。它是一个POJO，不依赖于特定于容器的接口，基类或注解。\r\n\r\n\r\n\r\n> 构造函数参数的解决办法\r\n\r\n通过使用参数标签来解决。如果Bean定义的构造函数参数中不存在潜在的歧义，则在实例化Bean时，在Bean定义中定义构造函数参数的顺序就是将这些参数提供给适当的构造函数的顺序。\r\n\r\n```java\r\npackage x.y;\r\n\r\npublic class ThingOne {\r\n\r\n    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n假设`ThingTwo`和`ThingThree`类不是通过继承关联的，则不存在潜在的歧义。因此，以下配置可以正常工作，并且无需在`<constructor-arg/>` 元素中显式指定构造函数参数索引或类型\r\n\r\n```xml\r\n<beans>\r\n    <bean id=\"beanOne\" class=\"x.y.ThingOne\">\r\n        <constructor-arg ref=\"beanTwo\"/>\r\n        <constructor-arg ref=\"beanThree\"/>\r\n    </bean>\r\n\r\n    <bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\r\n\r\n    <bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\r\n</beans>\r\n```\r\n\r\n当引用另一个bean时，类型是已知的，并且可以发生匹配（与前面的示例一样）。当使用诸如的简单类型时 `<value>true</value>`，Spring无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。\r\n\r\n```java\r\npackage examples;\r\n\r\npublic class ExampleBean {\r\n\r\n    // Number of years to calculate the Ultimate Answer\r\n    private int years;\r\n\r\n    // The Answer to Life, the Universe, and Everything\r\n    private String ultimateAnswer;\r\n\r\n    public ExampleBean(int years, String ultimateAnswer) {\r\n        this.years = years;\r\n        this.ultimateAnswer = ultimateAnswer;\r\n    }\r\n}\r\n```\r\n\r\n**构造函数参数类型匹配**\r\n\r\n在上述情况下，如果通过使用`type`属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配。如以下示例所示：\r\n\r\n```xml\r\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\r\n    <constructor-arg type=\"int\" value=\"7500000\"/>\r\n    <constructor-arg type=\"java.lang.String\" value=\"42\"/>\r\n</bean>\r\n```\r\n\r\n**构造函数参数索引**\r\n\r\n使用`index`属性来显式的指定构造函数参数的索引，例如：\r\n\r\n```xml\r\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\r\n    <constructor-arg index=\"0\" value=\"7500000\"/>\r\n    <constructor-arg index=\"1\" value=\"42\"/>\r\n</bean>\r\n```\r\n\r\n**构造函数参数名称**\r\n\r\n还可以使用构造函数参数名称来消除歧义，如以下示例所示：\r\n\r\n```xml\r\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\r\n    <constructor-arg name=\"years\" value=\"7500000\"/>\r\n    <constructor-arg name=\"ultimateAnswer\" value=\"42\"/>\r\n</bean>\r\n```\r\n\r\n\r\n\r\n### 基于Setter的依赖注入\r\n\r\n基于Setter的DI是通过在调用无参数构造函数或无参数静态工厂方法以实例化bean之后，在bean上调用setter方法来完成的。\r\n\r\n下面的示例显示只能通过使用纯setter注入来依赖注入的类。此类是常规的Java。它是一个POJO，不依赖于特定于容器的接口，基类或注释。\r\n\r\n```java\r\npublic class SimpleMovieLister {\r\n\r\n    // the SimpleMovieLister has a dependency on the MovieFinder\r\n    private MovieFinder movieFinder;\r\n\r\n    // a setter method so that the Spring container can inject a MovieFinder\r\n    public void setMovieFinder(MovieFinder movieFinder) {\r\n        this.movieFinder = movieFinder;\r\n    }\r\n\r\n    // business logic that actually uses the injected MovieFinder is omitted...\r\n}\r\n```\r\n\r\n`ApplicationContext`支持基于构造函数和基于setter对它管理的bean进行依赖注入。它也支持一些依赖通过构造函数方法注入之后，使用基于setter的依赖注入。使用`BeanDefinition`形式配置依赖项，结合`PropertyEditor`实例可以将属性从一种形式转成另一种形式。然而大多数Spring用户直接使用这些类（例如以编程形式），而使用XML定义bean，注解组件（例如类中使用 `@Component`，`@Controller`注解等等），或在基于Java的`@Configuration`类使用`@Bean`方法。\r\n\r\n------\r\n\r\n> **使用基于构造函数的依赖注入还是基于setter的依赖注入？**\r\n\r\n你可以混合使用基于构造函数的依赖注入和基于setter的依赖注入，强制依赖使用构造函数注入，可选依赖使用setter方法或配置方法注入是一个很好的经验法则。注意在setter方法上使用`@Required`注解会检查依赖是否注入。\r\n\r\n当实现的应用组件是不可变对象时，Spring团队通常主张构造函数注入，这样可以确保所需的依赖非空。此外，基于构造函数注入的组件总是以完全初始化状态返回客户（调用）代码。作为附注，含有许多构造函数参数的代码给人的感觉很差，这意味着类可能有很多职责，应该进行重构以便更好的处理关注问题的分离。\r\n\r\nsetter注入应该主要用来可选依赖上，在类内可以给可选依赖指定合理的默认值。此外，在每处使用依赖的代码都要进行非空检查。setter注入的一个好处就是setter方法使类的对象在后面可以进行再配置或再注入。`JMX MBeans`的管理是setter注入一个非常好的案例。\r\n\r\n使用依赖注入的类型对于特定的类是最有意义的。有时候，当处理没有源码的第三方类时，使用哪种方式取决于你。例如，如果第三方库没有提供任何setter方法，构造函数注入可能是依赖注入唯一可行的方式。\r\n\r\n------\r\n\r\n\r\n\r\n## 作用域\r\n\r\nSpring框架支持6种作用域，其中4种作用域只支持web的`ApplicationContext`。\r\n\r\n| 范围        | 描述                                                         |\r\n| ----------- | ------------------------------------------------------------ |\r\n| singleton   | （默认）将每个Spring IoC容器的单个bean definition 定位到单个对象实例 |\r\n| prototype   | 将单个bean定义的范围限定为任意数量的对象实例。               |\r\n| request     | 将单个bean definition 定位到单个HTTP请求的生命周期。也就是说，每个HTTP请求都有它自己的bean实例，该实例是在单个bean definition 创建的。仅在支持web的Spring ApplicationContext上下文中有效 |\r\n| session     | 将单个bean definition作用于HTTP会话的生命周期。仅在支持web的Spring ApplicationContext上下文中有效 |\r\n| application | 将单个bean定义作用于ServletContext的生命周期。仅在支持web的Spring ApplicationContext上下文中有效 |\r\n| websocket   | 将单个bean定义作用于WebSocket的生命周期。仅在支持web的Spring ApplicationContext上下文中有效 |\r\n\r\n\r\n\r\n### singleton\r\n\r\n**当一个 bean 的作用域为 singleton，那么Spring IoC容器中只会存在一个共享的 bean 实例，并且所有对 bean 的请求，只要 id 与该 bean 定义相匹配，则只会返回bean的同一实例。**\r\n\r\n换句话说，当定义一个bean definition 并且它的作用域是 singleton 时，Spring IoC容器会创建该bean definition 定义的对象的一个实例。 这个单一实例存储在这样的 singleton bean 缓存中，对这个已命名bean的所有后续请求和引用都会返回缓存的对象。\r\n\r\n```xml\r\n<bean id=\"accountService\" class=\"examples.DefaultAccountService\" scope=\"singleton\"/>\r\n```\r\n\r\n```java\r\n@Service\r\n@Scope(\"singleton\")\r\npublic class DefaultAccountService {\r\n	\r\n}\r\n```\r\n\r\n\r\n\r\n### prototype\r\n\r\n**当一个bean的作用域为 prototype，表示一个 bean 定义对应多个对象实例。** **prototype 作用域的 bean 会导致在每次对该 bean 请求**时都会创建一个新的 bean 实例。\r\n\r\n```xml\r\n<bean id=\"accountService\" class=\"examples.DefaultAccountService\" scope=\"prototype\"/>\r\n```\r\n\r\n它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。\r\n\r\n>当使用带有 prototype bean依赖项的 Singleton 作用域的bean时，**依赖项是在实例化时解析的**。 因此，如果将 prototype 作用域的bean依赖注入到 Singleton 作用域的bean中， 那么将实例化一个新的 prototype bean，然后依赖地注入到 Singleton bean中。 prototype 实例是提供给 Singleton 作用域bean的唯一实例。\r\n>\r\n>但是，如果要 Singleton 作用域bean在运行时重复获得 prototype 作用域bean 的新实例。 就不能将 prototype 作用域的bean依赖注入到 Singleton bean中，**因为该注入只在Spring容器实例化 Singleton bean并解析和注入其依赖项时发生一次**。\r\n\r\n\r\n\r\n### request\r\n\r\n**request只适用于Web程序，每一次 HTTP 请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，当请求结束后，该对象的生命周期即告结束。** 在 XML 中将 bean 定义成 request ，可以这样配置：\r\n\r\n```xml\r\n<bean id=\"loginAction\" class=\"examples.LoginAction\" scope=\"request\"/>\r\n```\r\n\r\n\r\n\r\n### session\r\n\r\nsession只适用于Web程序，session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效.与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的 HTTP session 中根据 userPreferences 创建的实例，将不会看到这些特定于某个 HTTP session 的状态变化。当HTTP session最终被废弃的时候，在该HTTP session作用域内的bean也会被废弃掉。\r\n\r\n```xml\r\n<bean id=\"userPreferences\" class=\"examplesUserPreferences\" scope=\"session\"/>\r\n```\r\n\r\n\r\n\r\n### globalSession\r\n\r\nglobal session 作用域类似于标准的 HTTP session 作用域，不过仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在global session 作用域中定义的 bean 被限定于全局portlet Session的生命周期范围内。\r\n\r\n```xml\r\n<bean id=\"user\" class=\"examples.Preferences \"scope=\"globalSession\"/>\r\n```\r\n\r\n\r\n\r\n## 生命周期\r\n\r\n一般指的是单例bean的生命周期\r\n\r\n\r\n\r\n![image-20210925142747453.png](https://i.loli.net/2021/09/25/VaKojgHdMZ5pUn8.png)\r\n\r\n\r\n从Ioc源码的`AbstractApplicationContext.java`中的`refresh()`方法看单例bean的生命周期\r\n\r\n\r\n\r\n### obtainFreshBeanFactory(beanFactory)\r\n\r\n先初始化BeanFactory容器,之后就是解析配置类，包括xml、注解和java配置类三种方式配置的bean，由BeanDefinitionReader将配置文件中的bean定义解析成一个个BeanDefinition，并且注册到BeanFactory中。\r\n\r\n\r\n\r\n### invokeBeanFactoryPostProcessors(beanFactory)\r\n\r\n首先获取spring配置中所有实现了`BeanFactoryPostProcessor`接口的bean，然后根据优先级调用`postProcessBeanFactory()`\r\n\r\n> BeanFactoryPostProcessor\r\n>\r\n> 实现该接口，可以在spring的bean创建之前，修改bean的定义属性。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置order属性来控制各个BeanFactoryPostProcessor的执行次序。\r\n>\r\n> 注意：BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。接口方法的参数是ConfigurrableListableBeanFactory，使用该参数，可以获取到相关bean的定义信息。\r\n\r\n\r\n\r\n### registerBeanPostProcessors(beanFactory)\r\n\r\n将`BeanPostProcessor`注册到beanFactory中\r\n\r\nbean的后置处理器，在bean初始化前后对bean进行一些处理\r\n\r\n>BeanPostProcessor，可以在spring容器实例化bean之后，在执行bean的初始化方法前后，添加一些自己的处理逻辑。这里说的初始化方法，指的是下面两种：\r\n>1）bean实现了InitializingBean接口，对应的方法为afterPropertiesSet\r\n>\r\n>2）在bean定义的时候，通过init-method设置的方法\r\n>\r\n>注意：BeanPostProcessor是在spring容器加载了bean的定义文件并且实例化bean之后执行的。BeanPostProcessor的执行顺序是在BeanFactoryPostProcessor之后。\r\n\r\n\r\n\r\n### finishBeanFactoryInitialization(beanFactory)\r\n\r\n初始化所有的单例并且是非懒加载的bean\r\n\r\n属性注入 `populateBean()`\r\n\r\n\r\n\r\n之后就是调用各种`Aware`接口\r\n\r\n>Aware接口\r\n>\r\n>```java\r\n>/* <p>Bean factory implementations should support the standard bean lifecycle interfaces\r\n> * as far as possible. The full set of initialization methods and their standard order is:\r\n> * <ol>\r\n> * <li>BeanNameAware\'s {@code setBeanName}\r\n> * <li>BeanClassLoaderAware\'s {@code setBeanClassLoader}\r\n> * <li>BeanFactoryAware\'s {@code setBeanFactory}\r\n> * <li>EnvironmentAware\'s {@code setEnvironment}\r\n> * <li>EmbeddedValueResolverAware\'s {@code setEmbeddedValueResolver}\r\n> * <li>ResourceLoaderAware\'s {@code setResourceLoader}\r\n> * (only applicable when running in an application context)\r\n> * <li>ApplicationEventPublisherAware\'s {@code setApplicationEventPublisher}\r\n> * (only applicable when running in an application context)\r\n> * <li>MessageSourceAware\'s {@code setMessageSource}\r\n> * (only applicable when running in an application context)\r\n> * <li>ApplicationContextAware\'s {@code setApplicationContext}\r\n> * (only applicable when running in an application context)\r\n> * <li>ServletContextAware\'s {@code setServletContext}\r\n> * (only applicable when running in a web application context)\r\n> * <li>{@code postProcessBeforeInitialization} methods of BeanPostProcessors\r\n> * <li>InitializingBean\'s {@code afterPropertiesSet}\r\n> * <li>a custom init-method definition\r\n> * <li>{@code postProcessAfterInitialization} methods of BeanPostProcessors\r\n> * </ol>\r\n> */\r\n>```\r\n>\r\n>以BeanFactoryAware为例，BeanFactoryAware\'s {@code setBeanFactory} 可以看出，就是往里面设置BeanFactory，方便后续获取。\r\n>\r\n>如果想获取BeanFactory，可以先实现一个Bean，实现BeanFactoryAware接口，就会把BeanFactory注入到当前Bean中。\r\n>\r\n>方便获取容器中的一些bean\r\n\r\n\r\n\r\n接着就是`BeanPostProcessor`的`postProcessBeforeInitialization()`\r\n\r\n之后处理 bean 中定义的 `init-method`，或者如果 bean 实现了 `InitializingBean` 接口，调用 `afterPropertiesSet()` 方法\r\n\r\n再之后就是`BeanPostProcessor`的`postProcessAfterInitialization()`\r\n\r\n此时就可以得到完整的单例bean了\r\n\r\n\r\n\r\n\r\n\r\n> 关于FactoryBean\r\n>\r\n> 可以自定义Bean的创建过程\r\n>\r\n> ```java\r\n> public interface FactoryBean<T> {\r\n>     //返回的对象实例\r\n>     T getObject() throws Exception;\r\n>     //Bean的类型\r\n>     Class<?> getObjectType();\r\n>     //true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true\r\n>     boolean isSingleton();\r\n> }\r\n> ```\r\n>\r\n> **即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用`getObject()`返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上`&`符号。**\r\n\r\n\r\n\r\n## reference\r\n\r\n[spring 官方文档](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core)\r\n\r\n[Spring的BeanFactoryPostProcessor和BeanPostProcessor](https://blog.csdn.net/caihaijiang/article/details/35552859)\r\n\r\n[Spring系列之FactoryBean](https://conan.blog.csdn.net/article/details/79572387)\r\n\r\n[Spring IOC 容器源码分析](https://javadoop.com/post/spring-ioc)', 'https://s2.loli.net/2022/03/07/hdHsCSprAbco4g6.jpg', '原创', 24, 1, 0, 1, 1, 1, '2022-03-07 10:32:20', '2021-09-25 07:42:38', '关于Spring Bean......', 6, 1);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `nickname` varchar(15) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `blog_id` int NULL DEFAULT NULL,
  `parent_comment_id` int NULL DEFAULT NULL,
  `is_admin_comment` int NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (1, 'aaa', '这是一条父评论', 'https://s2.loli.net/2022/03/06/9L1fvzXHtyGuU7E.jpg', '2021-09-23 05:48:43', 2, NULL, 0);
INSERT INTO `t_comment` VALUES (2, 'bbb', '这是一条子评论', 'https://s2.loli.net/2022/03/06/9L1fvzXHtyGuU7E.jpg', '2021-09-23 05:48:56', 2, 1, 0);
INSERT INTO `t_comment` VALUES (3, 'ccc', '这是一条子评论的子评论', 'https://s2.loli.net/2022/03/06/9L1fvzXHtyGuU7E.jpg', '2021-09-23 05:49:09', 2, 2, 0);
INSERT INTO `t_comment` VALUES (4, 'admin', '这是一条管理员评论', 'https://i.loli.net/2021/09/22/Sy8wbjzfPk4hpeG.jpg', '2021-09-24 15:32:36', 14, NULL, 1);

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (1, 'Java');
INSERT INTO `t_type` VALUES (2, '数据结构与算法');
INSERT INTO `t_type` VALUES (3, '网络');
INSERT INTO `t_type` VALUES (6, 'Spring');
INSERT INTO `t_type` VALUES (7, 'Web');
INSERT INTO `t_type` VALUES (8, 'mysql');
INSERT INTO `t_type` VALUES (9, 'JWT');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', '3063687049@qq.com', 'https://s2.loli.net/2022/03/05/WpfeY9PAa7mky2U.jpg', '管理员', '2021-09-22 12:46:23', '2021-09-22 12:46:26');

SET FOREIGN_KEY_CHECKS = 1;
